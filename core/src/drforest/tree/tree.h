#pragma once

#include <vector>
#include <memory>

namespace drforest {
    // indicators for leaf nodes (e.g. left_children is undefined)
    constexpr int64_t kTreeLeaf = -1;
    constexpr int64_t kTreeUndefined = -2;

    // Storage for node information
    struct Node {
        uint64_t node_id;                // id of the node in the tree
        int64_t feature;                 // id of direction or feature
        uint64_t depth;                  // depth of the node in the tree
        int64_t left_child;              // id of the left child of the node
        int64_t right_child;             // id of the right child of the node
        double threshold;                // Threshold value at the node
        double impurity;                 // Impurity of the node (i.e. the variance)
        double value;                    // predicted value at the node (mean)
        uint64_t num_node_samples;       // Number of samples at the node
        double weighted_n_node_samples;  // Weighted number of samples at the node
    };

    // A binary tree structure constructed by the TreeBuilder.
    class Tree {
    public:
        Tree();

        uint64_t add_node(uint64_t parent_id, uint64_t depth,
                          bool is_left, bool is_leaf,
                          arma::vec& direction, double threshold,
                          double impurity, double value,
                          uint64_t num_node_samples,
                          double weighted_n_node_samples);

        // Returns a copy of a given node.
        // NOTE: If the node is modified, the returned node is not!
        //       Not worth worrying about pointers for now.
        const Node& get_node(size_t node_id) const {
            return nodes_.at(node_id);
        }

        std::vector<Node> get_nodes() const {
            return nodes_;
        }

        // ONLY USE THIS IF YOU KNOW WHAT YOUR ARE DOING
        // It is primarly here for interfacing with python, where
        // we pass the node data to a numpy array
        Node* get_nodes_ptr() {
            return nodes_.data();
        }

        void set_random_state(uint random_state) {
            random_state_ = random_state;
        }

        void set_index_lookup(arma::uvec row_order) {
            row_order_ = row_order;
        }

        size_t num_nodes() const {
            return nodes_.size();
        }

        size_t num_directions() const {
            return directions_.n_cols;
        }

        // Get the directions of each node
        const arma::mat& get_directions() const {
            return directions_;
        }

        // This is primarly for interfacing with python, where
        // we pass the directions data directly to a numpy array
        double* get_directions_ptr() {
            return directions_.memptr();
        }

        // Returns index of the leaf node each sample falls into
        arma::uvec apply(const arma::mat& X) const;

        // Predicts the value stored in a given leaf node
        arma::vec predict(const arma::mat& X) const;

        // Records the path of each sample through the decision tree
        arma::umat decision_path(const arma::mat& X) const;

        // slice a matrix X according to the leaf node of the sample
        std::pair<arma::uvec, arma::uvec>
        get_leaf_slices(const arma::mat &X) const;

        arma::mat estimate_M(const arma::mat &X, const arma::mat &Z) const;

        // Estimates SDR sub-space based on slices generated by the leaf nodes
        arma::mat estimate_sufficient_dimensions(
            const arma::mat &X, DimensionReductionAlgorithm dr_algo) const;

        // indices of oob samples
        arma::uvec generate_oob_indices(bool return_unsorted_indices=true) const;

    private:
        uint64_t node_count_;
        uint64_t max_depth_;
        uint random_state_;
        arma::uvec row_order_;

        std::vector<Node> nodes_;
        arma::mat directions_;
    };

}  // namespace drforest
